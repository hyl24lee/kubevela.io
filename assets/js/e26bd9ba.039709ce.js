(self.webpackChunkkubevela_io=self.webpackChunkkubevela_io||[]).push([[32398],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},43887:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return o},toc:function(){return s},default:function(){return u}});var a=n(22122),i=n(19756),r=(n(67294),n(3905)),l={title:"Using GitOps + KubeVela for Application Continuous Delivery",author:"Tianxin Dong",author_title:"KubeVela Team",author_url:"https://github.com/oam-dev/kubevela",author_image_url:"https://kubevela.io/img/logo.svg",tags:["kubevela"],description:"",image:"https://raw.githubusercontent.com/oam-dev/kubevela.io/main/docs/resources/KubeVela-03.png",hide_table_of_contents:!1},o={permalink:"/blog/2021/10/10/kubevela-gitops",editUrl:"https://github.com/oam-dev/kubevela.io/tree/main/blog/2021-10-10-kubevela-gitops.md",source:"@site/blog/2021-10-10-kubevela-gitops.md",title:"Using GitOps + KubeVela for Application Continuous Delivery",description:"",date:"2021-10-10T00:00:00.000Z",formattedDate:"October 10, 2021",tags:[{label:"kubevela",permalink:"/blog/tags/kubevela"}],readingTime:12.375,truncated:!1,nextItem:{title:"KubeVela Releases 1.1, Reaching New Peaks in Cloud-Native Continuous Delivery",permalink:"/blog/2021/10/08/blog-1.1"}},s=[{value:"What is GitOps",id:"what-is-gitops",children:[]},{value:"GitOps with KubeVela",id:"gitops-with-kubevela",children:[]},{value:"GitOps workflow",id:"gitops-workflow",children:[]},{value:"For platform administrators/SREs",id:"for-platform-administratorssres",children:[]},{value:"Setup Config Repository",id:"setup-config-repository",children:[]},{value:"Modify the config for GitOps trigger",id:"modify-the-config-for-gitops-trigger",children:[]},{value:"For developers",id:"for-developers",children:[{value:"Setup App Code Repository",id:"setup-app-code-repository",children:[]}]},{value:"Create Git Secret for KubeVela committing to Config Repo",id:"create-git-secret-for-kubevela-committing-to-config-repo",children:[]},{value:"Setup Config Repository",id:"setup-config-repository-1",children:[]},{value:"Modify the code",id:"modify-the-code",children:[]},{value:"Summary",id:"summary",children:[]}],p={toc:s};function u(e){var t=e.components,l=(0,i.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"KubeVela is a simple, easy-to-use, and highly extensible cloud-native application platform. It can make developers deliver microservices applications easily, without knowing Kubernetes details."),(0,r.kt)("p",null,"KubeVela is based on OAM model, which naturally solves the orchestration problems of complex resources. It means that KubeVela can manage complex large-scale applications with GitOps. Convergence of team and system size after the system complexity problem."),(0,r.kt)("h2",{id:"what-is-gitops"},"What is GitOps"),(0,r.kt)("p",null,"GitOps is a modern way to do continuous delivery. Its core idea is to have a Git repository which contains environmental and application configurations. An automated process is also needed for sync the config to cluster."),(0,r.kt)("p",null,"By changing the files in repository, developers can apply the applications automatically. The benefits of applying GitOps include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Increased productivity. Continuous delivery can speed up the time of deployment."),(0,r.kt)("li",{parentName:"ul"},"Lower the barrier for developer to deploy. By pushing code instead of container configuration, developers can easily deploy Kubernetes without knowing its internal implementation."),(0,r.kt)("li",{parentName:"ul"},"Trace the change records. Managing the cluster with Git makes every change traceable, enhancing the audit trail."),(0,r.kt)("li",{parentName:"ul"},"Recover the cluster with Git's rollback and branch.")),(0,r.kt)("h2",{id:"gitops-with-kubevela"},"GitOps with KubeVela"),(0,r.kt)("p",null,"KubeVela as an declarative application delivery control plane can be naturally used in GitOps approach, and this will provide below extra bonus to end users alongside with GitOps benefits:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"application delivery workflow (CD pipeline)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"i.e. KubeVela supports pipeline style application delivery process in GitOps, instead of simply declaring final status;"))),(0,r.kt)("li",{parentName:"ul"},"handling deployment dependencies and designing typologies (DAG);"),(0,r.kt)("li",{parentName:"ul"},"unified higher level abstraction atop various GitOps tools' primitives;"),(0,r.kt)("li",{parentName:"ul"},"declare, provision and consume cloud resources in unified application definition;"),(0,r.kt)("li",{parentName:"ul"},"various out-of-box deployment strategies (Canary, Blue-Green ...);"),(0,r.kt)("li",{parentName:"ul"},"various out-of-box hybrid/multi-cloud deployment policies (placement rule, cluster selectors etc.);"),(0,r.kt)("li",{parentName:"ul"},"Kustomize-style patch for multi-env deployment without the need to learn Kustomize at all;"),(0,r.kt)("li",{parentName:"ul"},"... and much more.")),(0,r.kt)("p",null,"In this section, we will introduce steps of using KubeVela directly in GitOps approach."),(0,r.kt)("h2",{id:"gitops-workflow"},"GitOps workflow"),(0,r.kt)("p",null,"The GitOps workflow is divided into CI and CD:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CI(Continuous Integration): Continuous integration builds code and images, and pushes images to the registry. There are many CI tools like GitHub Action, Travis, Jenkins and so on. In this article, we use GitHub Action for CI. You can also use other CI tools. KubeVela can connect CI processes under any tool around GitOps."),(0,r.kt)("li",{parentName:"ul"},"CD(Continuous Delivery): Continuous delivery automatically updates the configuration in the cluster. For example, update the latest images in the registry to the cluster.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Currently there are two main CD modes:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Push-based: Push mode CD is mainly accomplished by configuring CI pipeline. In this way, the access key of the cluster is shared with CI so that the CI pipeline can push changes to the cluster. For this mode, please refer to our previous blog post: ",(0,r.kt)("a",{parentName:"li",href:"/blog/2021/09/02/kubevela-jenkins-cicd"},"Using Jenkins + KubeVela for Application Continuous Delivery"),"."),(0,r.kt)("li",{parentName:"ul"},"Pull-based: Pull mode CD listens for changes to the repository (code repository or configuration repository) in the cluster and synchronizes those changes to the cluster. In this way, the cluster actively pulls the update, thus avoiding the problem of exposing the secret key. This article will introduce using KubeVela and GitOps in pull mode.")))))),(0,r.kt)("p",null,"This article will separate into two perspectives:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"For platform administrators/SREs, they can update the config in Git repo. It will trigger automated re-deployment.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"For developers, they can update the app source code and then push it to Git. It will trigger building latest image and re-deployment."))),(0,r.kt)("h2",{id:"for-platform-administratorssres"},"For platform administrators/SREs"),(0,r.kt)("p",null,"Platform administrators/SREs prepares the Git repo for operational config. Every config config change will be traceable by that. KubeVela will watch the repo and apply changes to the clusters."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"alt",src:n(96017).Z})),(0,r.kt)("h2",{id:"setup-config-repository"},"Setup Config Repository"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The configuration files are from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/oam-dev/samples/tree/master/9.GitOps_Demo/for-SREs"},"Example Repo"),".")),(0,r.kt)("p",null,"In this example, we will deploy an application and a database, the application uses the database to store data."),(0,r.kt)("p",null,"The structure of the config repository looks below:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"clusters/")," contains the GitOps config. It will command KubeVela to watch the specified repo and apply latest changes."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"apps/")," contains the Application yaml for deploying the user-facing app."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"infrastructure/")," contains infrastructure tools, i.e. MySQL database.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"\u251c\u2500\u2500 apps\n\u2502\xa0\xa0 \u2514\u2500\u2500 my-app.yaml\n\u251c\u2500\u2500 clusters\n\u2502\xa0\xa0 \u251c\u2500\u2500 apps.yaml\n\u2502\xa0\xa0 \u2514\u2500\u2500 infra.yaml\n\u2514\u2500\u2500 infrastructure\n    \u2514\u2500\u2500 mysql.yaml\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"KubeVela recommends using the directory structure above to manage your GitOps repository. ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," holds the associated KubeVela GitOps configuration that need to be applied to cluster manually, ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/")," holds your application and ",(0,r.kt)("inlineCode",{parentName:"p"},"infrastructure/")," holds your base configuration. By separating applications from basic configurations, you can manage your deployment environment more reasonably and isolate application changes.")),(0,r.kt)("h4",{id:"directory-clusters"},"Directory ",(0,r.kt)("inlineCode",{parentName:"h4"},"clusters/")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," is the initialize configuration directory for KubeVela GitOps."),(0,r.kt)("p",null,"Below is how the ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/infra.yaml")," looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: infra\nspec:\n  components:\n  - name: database-config\n    type: kustomize\n    properties:\n      repoType: git\n      # replace it with your repo url\n      url: https://github.com/FogDong/KubeVela-GitOps-Infra-Demo\n      # replace it with your git secret if it's a private repo\n      # secretRef: git-secret\n      # the pull interval time, set to 10m since the infrastructure is steady\n      pullInterval: 10m\n      git:\n        # the branch name\n        branch: main\n      # the path to sync\n      path: ./infrastructure\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"apps.yaml")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"infra.yaml")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," are similar. Their difference is to watch different directories. In ",(0,r.kt)("inlineCode",{parentName:"p"},"apps.yaml"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"properties.path")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"./apps"),"."),(0,r.kt)("p",null,"Apply the files in ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," manually. They will sync the files in ",(0,r.kt)("inlineCode",{parentName:"p"},"infrastructure/")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/")," dir of the Git repo."),(0,r.kt)("h4",{id:"directory-apps"},"Directory ",(0,r.kt)("inlineCode",{parentName:"h4"},"apps/")),(0,r.kt)("p",null,"The file in ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/")," is a simple application with database information and Ingress. The app serves HTTP service and connects to a MySQL database. In the '/' path, it will display the version in the code; in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/db")," path, it will list the data in database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  components:\n    - name: my-server\n      type: webservice\n      properties:\n        image: <your image address> # {"$imagepolicy": "default:apps"}\n        port: 8088\n        env:\n          - name: DB_HOST\n            value: mysql-cluster-mysql.default.svc.cluster.local:3306\n          - name: DB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                name: mysql-secret\n                key: ROOT_PASSWORD\n      traits:\n        - type: ingress\n          properties:\n            domain: testsvc.example.com\n            http:\n              /: 8088\n')),(0,r.kt)("p",null,"This is an Application binds with Traits Ingress. In this way, the underlying Deployment, Service, and Ingress can be brought together in a single file, making it easier to manage the application."),(0,r.kt)("h4",{id:"directory-infrastructure"},"Directory ",(0,r.kt)("inlineCode",{parentName:"h4"},"infrastructure/")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"infrastructure/")," contains the config of some infrastructures like database. In the following, we will use ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bitpoke/mysql-operator"},"MySQL operator")," to deploy a MySQL cluster."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Notice that there must be a secret in your cluster with MySQL password specified in key ",(0,r.kt)("inlineCode",{parentName:"p"},"ROOT_PASSWORD"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: mysql\n  namespace: default\nspec:\n  components:\n    - name: mysql-controller\n      type: helm\n      properties:\n        repoType: helm\n        url: https://presslabs.github.io/charts\n        chart: mysql-operator\n        version: "0.4.0"\n    - name: mysql-cluster\n      type: raw\n      dependsOn:\n        - mysql-controller\n      properties:\n        apiVersion: mysql.presslabs.org/v1alpha1\n        kind: MysqlCluster\n        metadata:\n          name: mysql-cluster\n        spec:\n          replicas: 1\n          # replace it with your secret\n          secretName: mysql-secret\n')),(0,r.kt)("p",null,"We use workflow in this Application. The first step is to deploy the MySQL controller, after the controller is running, the second step will deploy the MySQL cluster."),(0,r.kt)("h4",{id:"apply-the-files-in-clusters"},"Apply the files in ",(0,r.kt)("inlineCode",{parentName:"h4"},"clusters/")),(0,r.kt)("p",null,"After storing bellow files in the Git config repo, we need to apply the GitOps config files in ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," manually."),(0,r.kt)("p",null,"First, apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/infra.yaml")," to cluster, we can see that the MySQL in ",(0,r.kt)("inlineCode",{parentName:"p"},"infrastructure/")," is automatically deployed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl apply -f clusters/infra.yaml\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ vela ls\n\nAPP     COMPONENT           TYPE        TRAITS  PHASE   HEALTHY STATUS  CREATED-TIME\ninfra   database-config     kustomize           running healthy         2021-09-26 20:48:09 +0800 CST\nmysql   mysql-controller    helm                running healthy         2021-09-26 20:48:11 +0800 CST\n\u2514\u2500      mysql-cluster       raw                 running healthy         2021-09-26 20:48:11 +0800 CST\n")),(0,r.kt)("p",null,"Apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/apps.yaml")," to cluster, we can see that the application in ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/")," is automatically deployed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl apply -f clusters/apps.yaml\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"APP     COMPONENT           TYPE        TRAITS  PHASE   HEALTHY STATUS  CREATED-TIME\napps    apps                kustomize           running healthy         2021-09-27 16:55:53 +0800 CST\ninfra   database-config     kustomize           running healthy         2021-09-26 20:48:09 +0800 CST\nmy-app  my-server           webservice  ingress running healthy         2021-09-27 16:55:55 +0800 CST\nmysql   mysql-controller    helm                running healthy         2021-09-26 20:48:11 +0800 CST\n\u2514\u2500      mysql-cluster       raw                 running healthy         2021-09-26 20:48:11 +0800 CST\n")),(0,r.kt)("p",null,"By deploying the KubeVela GitOps config files, we now automatically apply the application and database in cluster."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"curl")," the Ingress of the app, we can see that the current version is ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1.5")," and the application is connected to the database successfully:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ kubectl get ingress\nNAME        CLASS    HOSTS                 ADDRESS         PORTS   AGE\nmy-server   <none>   testsvc.example.com   <ingress-ip>    80      162m\n\n$ curl -H "Host:testsvc.example.com" http://<ingress-ip>\nVersion: 0.1.5\n\n$ curl -H "Host:testsvc.example.com" http://<ingress-ip>/db\nUser: KubeVela\nDescription: It\'s a test user\n')),(0,r.kt)("h2",{id:"modify-the-config-for-gitops-trigger"},"Modify the config for GitOps trigger"),(0,r.kt)("p",null,"After the first deployment, we can modify the files in config repo to update the applications in the cluster."),(0,r.kt)("p",null,"Modify the domain of the application's Ingress:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n      traits:\n        - type: ingress\n          properties:\n            domain: kubevela.example.com\n            http:\n              /: 8089\n")),(0,r.kt)("p",null,"Check the Ingress in cluster after a while:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"NAME        CLASS    HOSTS                 ADDRESS         PORTS   AGE\nmy-server   <none>   kubevela.example.com  <ingress-ip>    80      162m\n")),(0,r.kt)("p",null,"The host of the Ingress has been updated successfully!"),(0,r.kt)("p",null,"In this way, we can edit the files in the Git repo to update the cluster."),(0,r.kt)("h2",{id:"for-developers"},"For developers"),(0,r.kt)("p",null,"Developers writes the application source code and push it to a Git repo (aka app repo). Once app repo updates, the CI will build the image and push it to the image registry. KubeVela watches the image registry, and updates the image in config repo. Finally, it will apply the config to the cluster."),(0,r.kt)("p",null,"User can update the configuration in the cluster automatically when the code is updated."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"alt",src:n(17544).Z})),(0,r.kt)("h3",{id:"setup-app-code-repository"},"Setup App Code Repository"),(0,r.kt)("p",null,"Setup a Git repository with source code and Dockerfile."),(0,r.kt)("p",null,"The app serves HTTP service and connects to a MySQL database. In the '/' path, it will display the version in the code; in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/db")," path, it will list the data in database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {\n        _, _ = fmt.Fprintf(w, "Version: %s\\n", VERSION)\n    })\n    http.HandleFunc("/db", func(w http.ResponseWriter, r *http.Request) {\n        rows, err := db.Query("select * from userinfo;")\n        if err != nil {\n            _, _ = fmt.Fprintf(w, "Error: %v\\n", err)\n        }\n        for rows.Next() {\n            var username string\n            var desc string\n            err = rows.Scan(&username, &desc)\n            if err != nil {\n                _, _ = fmt.Fprintf(w, "Scan Error: %v\\n", err)\n            }\n            _, _ = fmt.Fprintf(w, "User: %s \\nDescription: %s\\n\\n", username, desc)\n        }\n    })\n\n    if err := http.ListenAndServe(":8088", nil); err != nil {\n        panic(err.Error())\n    }\n')),(0,r.kt)("p",null,"In this tutorial, we will setup a CI pipeline using GitHub Actions to build the image and push it to a registry. The code and configuration files are from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/oam-dev/samples/tree/master/9.GitOps_Demo/for-developers/app-code"},"Example Repo"),"."),(0,r.kt)("h2",{id:"create-git-secret-for-kubevela-committing-to-config-repo"},"Create Git Secret for KubeVela committing to Config Repo"),(0,r.kt)("p",null,"After the new image is pushed to the image registry, KubeVela will be notified and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"Application")," file in the Git repository and cluster. Therefore, we need a secret with Git information for KubeVela to commit to the Git repository. Fill the following yaml files with your password and apply it to the cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-secret\ntype: kubernetes.io/basic-auth\nstringData:\n  username: <your username>\n  password: <your password>\n")),(0,r.kt)("h2",{id:"setup-config-repository-1"},"Setup Config Repository"),(0,r.kt)("p",null,"The configuration repository is almost the same as the previous configuration, you only need to add the image registry config to the file. For more details, please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/oam-dev/samples/tree/master/9.GitOps_Demo/for-developers/kubevela-config"},"Example Repository"),"."),(0,r.kt)("p",null,"Add the config of image registry in ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/apps.yaml"),", it listens for image updates in the image registry:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n  imageRepository:\n    image: <your image>\n    # if it's a private image registry, use `kubectl create secret docker-registry` to create the secret\n    # secretRef: imagesecret\n    filterTags:\n      # filter the image tag\n      pattern: '^master-[a-f0-9]+-(?P<ts>[0-9]+)'\n      extract: '$ts'\n    # use the policy to sort the latest image tag and update\n    policy:\n      numerical:\n        order: asc\n    # add more commit message\n    commitMessage: \"Image: {{range .Updated.Images}}{{println .}}{{end}}\"\n")),(0,r.kt)("p",null,"Modify the image field in ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/my-app.yaml")," and add annotation ",(0,r.kt)("inlineCode",{parentName:"p"},'# {"$imagepolicy": "default:apps"}'),".\nNotice that KubeVela will only be able to modify the image field if the annotation is added after the field. ",(0,r.kt)("inlineCode",{parentName:"p"},"default:apps")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"namespace:name")," of the GitOps config file above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  components:\n    - name: my-server\n      type: webservice\n      properties:\n        image: ghcr.io/fogdong/test-fog:master-cba5605f-1632714412 # {"$imagepolicy": "default:apps"}\n')),(0,r.kt)("p",null,"After update the files in ",(0,r.kt)("inlineCode",{parentName:"p"},"clusters/")," to cluster, we can then update the application by modifying the code."),(0,r.kt)("h2",{id:"modify-the-code"},"Modify the code"),(0,r.kt)("p",null,"Change the ",(0,r.kt)("inlineCode",{parentName:"p"},"Version")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1.6")," and modify the data in database:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'const VERSION = "0.1.6"\n\n...\n\nfunc InsertInitData(db *sql.DB) {\n    stmt, err := db.Prepare(insertInitData)\n    if err != nil {\n        panic(err)\n    }\n    defer stmt.Close()\n\n    _, err = stmt.Exec("KubeVela2", "It\'s another test user")\n    if err != nil {\n        panic(err)\n    }\n}\n')),(0,r.kt)("p",null,"Commit the change to the Git Repository, we can see that our CI pipelines has built the image and push it to the image registry."),(0,r.kt)("p",null,"KubeVela will listen to the image registry and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"apps/my-app.yaml")," in Git Repository with the latest image tag."),(0,r.kt)("p",null,"We can see that there is a commit form ",(0,r.kt)("inlineCode",{parentName:"p"},"kubevelabot"),", the commit message is always with a prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"Update image automatically.")," You can use format like ",(0,r.kt)("inlineCode",{parentName:"p"},"{{range .Updated.Images}}{{println .}}{{end}}")," to specify the image name in the ",(0,r.kt)("inlineCode",{parentName:"p"},"commitMessage")," field."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"alt",src:n(28298).Z})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that if you want to put the code and config in the same repository, you need to filter out the commit from KubeVela in CI configuration like below to avoid the repeat build of pipeline."),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"jobs:\n publish:\n   if: \"!contains(github.event.head_commit.message, 'Update image automatically')\"\n"))),(0,r.kt)("p",null,"Re-check the ",(0,r.kt)("inlineCode",{parentName:"p"},"Application")," in cluster, we can see that the image of the ",(0,r.kt)("inlineCode",{parentName:"p"},"my-app")," has been updated after a while."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"KubeVela polls the latest information from the code and image repo periodically (at an interval that can be customized):"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"When the ",(0,r.kt)("inlineCode",{parentName:"li"},"Application")," file in the Git repository is updated, KubeVela will update the ",(0,r.kt)("inlineCode",{parentName:"li"},"Application")," in the cluster based on the latest configuration."),(0,r.kt)("li",{parentName:"ul"},"When a new tag is added to the image registry, KubeVela will filter out the latest tag based on your policy and update it to Git repository. When the files in the repository are updated, KubeVela repeats the first step and updates the files in the cluster, thus achieving automatic deployment."))),(0,r.kt)("p",null,"We can ",(0,r.kt)("inlineCode",{parentName:"p"},"curl")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Ingress")," to see the current version and data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ kubectl get ingress\nNAME        CLASS    HOSTS                 ADDRESS         PORTS   AGE\nmy-server   <none>   kubevela.example.com  <ingress-ip>    80      162m\n\n$ curl -H "Host:kubevela.example.com" http://<ingress-ip>\nVersion: 0.1.6\n\n$ curl -H "Host:kubevela.example.com" http://<ingress-ip>/db\nUser: KubeVela\nDescription: It\'s a test user\n\nUser: KubeVela2\nDescription: It\'s another test user\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Version")," has been updated successfully! Now we're done with everything from changing the code to automatically applying to the cluster."),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"For platform admins/SREs, they update the config repo to operate the application and infrastructure. KubeVela will synchronize the config to the cluster, simplifying the deployment process."),(0,r.kt)("p",null,"For end users/developers, they write the source code, push it to Git, and then re-deployment will happen. It will make CI to build the image. KubeVela will then update the image field and apply the deployment config."),(0,r.kt)("p",null,"By integrating with GitOps, KubeVela helps users speed up deployment and simplify continuous deployment."))}u.isMDXComponent=!0},17544:function(e,t,n){"use strict";t.Z=n.p+"assets/images/dev-flow-e2153e9687ba8904dddea46db8aa7a85.jpg"},28298:function(e,t,n){"use strict";t.Z=n.p+"assets/images/gitops-commit-31c4a9477065754e172f97792bb14f91.png"},96017:function(e,t,n){"use strict";t.Z=n.p+"assets/images/ops-flow-8bec0d06df6baf12234cfe6c18bff438.jpg"}}]);